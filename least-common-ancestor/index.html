<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 最近公共祖先问题 · Jemoii's Blog</title><meta name="description" content="最近公共祖先问题 - Jemoii"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://g.hijkl.mn/atom.xml" title="Jemoii's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jemoii" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">最近公共祖先问题</h1><div class="post-info">2016年3月28日</div><div class="post-content"><p>#####从git merge说起</p>
<p>接着 <a href="http://jemoii.github.io/blog/working-with-git/" target="_blank" rel="external">使用Git协同工作</a> 中的内容，使用伪代码描述<code>git merge</code>的原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">找到目标分支current和被合并分支merge的共同祖先分支ancestor；</div><div class="line">// 在fix_bug分支上执行git merge master</div><div class="line">// master为目标分支，fix_bug为被合并分支</div><div class="line">if(ancestor == merge) &#123;</div><div class="line">	return;</div><div class="line">&#125; else if(ancestor == current) &#123;</div><div class="line">	fast forward merge，分支current指向merge</div><div class="line">&#125; else &#123;</div><div class="line">	确定ancestor与merge的差异</div><div class="line">	try &#123;</div><div class="line">    	将差异合并到current</div><div class="line">    &#125; catch(合并出现矛盾) &#123;</div><div class="line">    	添加矛盾标记，通知用户解决矛盾</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    根据current、merge创建新的子分支</div><div class="line">    分支current指向新的子分支</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Git的分支结构为树形结构，这里找到两个分支的共同祖先分支，即<code>求树中两个节点的最近公共祖先</code>。</p>
<p>如果每个分支可以确定其父分支，即树中节点具有指向其父亲的parent指针，那问题可以转化为<code>求两个链表的公共节点</code>。两个节点分别使用parent指针遍历到根节点root，遍历步数之差即两节点到公共节点的步数之差，由步数较大的节点先遍历步数之差对应的步数，接着两节点同时使用parent指针遍历，当parent指针的指向一致时，其指向即所求的公共节点。可以进一步参考 <a href="http://zhedahht.blog.163.com/blog/static/254111742008053169567/" target="_blank" rel="external">两链表的第一个公共结点</a> 。</p>
<p>如果树为平衡二叉树，根据BST的性质，从根节点root开始遍历，如果当前节点的值同时大于两节点的值，说明两节点都位于当前节点的左子树，接下来向左子树遍历；如果当前节点的值同时小于两节点的值，说明两节点都位于当前节点的右子树，接下来向右子树遍历；如果当前节点的值位于两节点的值之间，那当前节点即所求的公共节点。</p>
<p>下面介绍使用<code>Tarjan离线算法</code>解决上述问题，Tarjan算法基于深度遍历和<code>并查集</code>，先介绍并查集相关的内容。</p>
<p>#####并查集</p>
<p><a href="http://blog.csdn.net/dellaserss/article/details/7724401" target="_blank" rel="external">并查集详解 (转)</a> 非常生动地介绍了并查集相关的内容，这里给出并查集的Java实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] set;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_SET_SIZE = <span class="number">8</span>;</div><div class="line">	<span class="comment">/** 参数超出并查集下标范围，返回ERROR_INDEX */</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_INDEX = -<span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>(INIT_SET_SIZE);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">		set = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; set.length; i++) &#123;</div><div class="line">			set[i] = i;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * 等价于find(x, true)</span></div><div class="line"><span class="comment">	 * </span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></div><div class="line"><span class="comment">	 * <span class="doctag">@return</span></span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (outOfLength(x)) &#123;</div><div class="line">			<span class="keyword">return</span> ERROR_INDEX;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (set[x] != x) &#123;</div><div class="line">			set[x] = find(set[x]);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> set[x];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * </span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> compress</span></div><div class="line"><span class="comment">	 *            是否压缩路径</span></div><div class="line"><span class="comment">	 * <span class="doctag">@return</span> x超出并查集下标范围，返回ERROR_INDEX；否则返回x的根元素</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">boolean</span> compress)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (outOfLength(x)) &#123;</div><div class="line">			<span class="keyword">return</span> ERROR_INDEX;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (compress) &#123;</div><div class="line">			<span class="keyword">return</span> find(x);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">int</span> temp = x;</div><div class="line">		<span class="keyword">while</span> (set[temp] != temp) &#123;</div><div class="line">			temp = set[temp];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> temp;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * </span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> y</span></div><div class="line"><span class="comment">	 * <span class="doctag">@return</span> x、y的根元素是否相等</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (outOfLength(x) || outOfLength(y)) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> find(x) == find(y);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line"><span class="comment">	 * 将x、y合并到同一根元素下</span></div><div class="line"><span class="comment">	 * </span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> x</span></div><div class="line"><span class="comment">	 * <span class="doctag">@param</span> y</span></div><div class="line"><span class="comment">	 */</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> prex = find(x);</div><div class="line">		<span class="keyword">int</span> prey = find(y);</div><div class="line">		<span class="keyword">if</span> (prex != ERROR_INDEX &amp;&amp; prey != ERROR_INDEX &amp;&amp; prex != prey) &#123;</div><div class="line">			set[prex] = prey;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">outOfLength</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> index &lt; <span class="number">0</span> || index &gt;= set.length;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####Tanjar离线算法</p>
<p>理解并查集之后，Tanjar算法即将并查集与深度遍历有效结合，伪代码描述原理为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Tarjan(u) &#123;</div><div class="line">	begin</div><div class="line">		设置u号节点的祖先为u</div><div class="line">        深度遍历u的子树</div><div class="line">        访问每一条与u相关的询问u和v</div><div class="line">        	-若v已经被访问过，则输出v当前的祖先t</div><div class="line">        标记u为已被访问，将所有u的子节点包括u本身的祖先改为u的父节点</div><div class="line">    end</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的Java实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> queryList</span></div><div class="line"><span class="comment"> *            LCA查询条件列表，Query类的u、v属性为查询条件，即已知的两节点；ancestor属性保存查询结果，即公共节点</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(TreeNode node, ArrayList&lt;Query&gt; queryList)</span> </span>&#123;</div><div class="line">	node.ancestor = node;<span class="comment">// 初始标记node的祖先为自己</span></div><div class="line">	<span class="keyword">for</span> (TreeNode child : node.children) &#123;</div><div class="line">		tarjan(child, queryList);<span class="comment">// 深度遍历</span></div><div class="line">		join(child, node);<span class="comment">// 将子节点的祖先修改为node</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	node.searched = <span class="keyword">true</span>;<span class="comment">// 标记node已被访问</span></div><div class="line">	<span class="comment">// 遍历查询条件，如果查询条件与node相关且两节点已被访问，基于并查集查找公共节点</span></div><div class="line">	<span class="keyword">for</span> (Query query : queryList) &#123;</div><div class="line">		<span class="keyword">if</span> (query.u == node) &#123;</div><div class="line">			<span class="keyword">if</span> (query.v.searched) &#123;</div><div class="line">				query.ancestor = find(query.v);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (query.v == node) &#123;</div><div class="line">			<span class="keyword">if</span> (query.u.searched) &#123;</div><div class="line">				query.ancestor = find(query.u);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/about-suffix-array-and-else/" class="prev">上一篇</a><a href="/explanation-for-concurrenthashmap/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://g.hijkl.mn">Jemoii</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>