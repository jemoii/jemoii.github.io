<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Spring学习之从refresh说起 · Jemoii's Blog</title><meta name="description" content="Spring学习之从refresh说起 - Jemoii"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://g.hijkl.mn/atom.xml" title="Jemoii's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jemoii" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spring学习之从refresh说起</h1><div class="post-info">2017年2月22日</div><div class="post-content"><p>这里我们以<code>ClassPathXmlApplicationContext</code>为例，跟踪Spring的启动过程，其实主要是跟踪AbstractApplicationContext.refresh。</p>
<p>#####1</p>
<p>跟踪源码来到AbstractApplicationContext#prepareRefresh中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Validate that all properties marked as required are resolvable</span></div><div class="line"><span class="comment">// see ConfigurablePropertyResolver#setRequiredProperties</span></div><div class="line">getEnvironment().validateRequiredProperties();</div></pre></td></tr></table></figure>
<p>那我们就先来看一下<code>Environment</code>相关的内容。</p>
<p><code>AbstractApplicationContext</code>内置了<code>environment</code>变量，getEnvironment通过createEnvironment方法，将<code>environment</code>实例化为<code>StandardEnvironment</code>。下面的代码算是一个概括性描述，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> ConfigurableEnvironment environment = <span class="keyword">new</span> StandardEnvironment();</div></pre></td></tr></table></figure>
<p><code>StandardEnvironment</code>重写了customizePropertySources方法，目的是在实例化时将System.getProperties()获取的系统属性以及System.getenv()获取的系统环境变量添加到<code>propertySources</code>中。<code>propertySources</code>是基于<code>CopyOnWriteArrayList&lt;PropertySource&lt;?&gt;&gt;</code>实现的<code>MutablePropertySources</code>实例。</p>
<p><img src="https://moetu.fastmirror.org/images/2017/09/20/standardenvironment_umlfb0c0742875b9d39.jpg" alt=""></p>
<p>除了重写customizePropertySources方法，其他的方法仍由<code>AbstractEnvironment</code>来实现，<code>propertySources</code>即内置于<code>AbstractEnvironment</code>。从上图可以看出<code>AbstractEnvironment</code>同时实现了<code>Environment</code>和<code>ConfigurablePropertyResolver</code>接口，<code>AbstractEnvironment</code>基于<code>LinkedHashSet</code>实现了<code>Environment</code>（profile）相关的方法，而<code>ConfigurablePropertyResolver</code>相关的方法则由其内置的一个<code>PropertySourcesPropertyResolver</code>实例来实现。比如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException </span>&#123;</div><div class="line">	<span class="keyword">this</span>.propertyResolver.validateRequiredProperties();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####2</p>
<p>接着来到AbstractApplicationContext#obtainFreshBeanFactory中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">refreshBeanFactory();</div></pre></td></tr></table></figure>
<p>上述方法由AbstractRefreshableApplicationContext#refreshBeanFactory实现，销毁相关的bean（清理bean相关的对象），关闭BeanFactory，重新实例化BeanFactory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DefaultListableBeanFactory beanFactory = <span class="keyword">new</span> DefaultListableBeanFactory(<span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>beanFactory通过内置的<code>serializableFactories</code>保存<code>serializationId</code>与其自身弱引用的对应关系。在下面提到的<code>loadBeanDefinitions</code>结束之后，将beanFactory赋给<code>AbstractApplicationContext</code>内置的<code>beanFactory</code>。</p>
<p><code>loadBeanDefinitions</code>方法被多次重载，最终到AbstractBeanDefinitionReader#loadBeanDefinitions(String, Set)可以分为两部分，第一部分是获取资源文件，第二部分是从资源文件中获取BeanDefinition。</p>
<ul>
<li>getResources</li>
</ul>
<p>beanFactory自身作为<code>XmlBeanDefinitionReader</code>内置的<code>resourceLoader</code>，得到<code>XmlBeanDefinitionReader</code>实例，同时将其<code>environment</code>赋值给<code>XmlBeanDefinitionReader</code>内置的<code>environment</code>。</p>
<p>reader将getResources的任务交给其实例化时的<code>resourceLoader</code>，即beanFactory；beanFactory又将getResources的任务交给其内置的<code>resourcePatternResolver</code>（<code>PathMatchingResourcePatternResolver</code>实例）。</p>
<ul>
<li>loadBeanDefinitions</li>
</ul>
<p>继续跟踪源码来到DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</div><div class="line">	String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</div><div class="line">	<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</div><div class="line">		String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</div><div class="line">			profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</div><div class="line">		<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里如果元素配置了profile属性，则会通过前面的<code>environment</code>检查配置的profile是否符合，如果不符合则跳过当前资源文件。</p>
<p>接着来到DefaultBeanDefinitionDocumentReader#processBeanDefinition中的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</div><div class="line">...</div><div class="line">	<span class="comment">// Register the final decorated instance.</span></div><div class="line">	BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</div></pre></td></tr></table></figure>
<p>BeanDefinitionReaderUtils#createBeanDefinition返回<code>GenericBeanDefinition</code>实例，设置其相应的属性，包装成<code>BeanDefinitionHolder</code>实例。</p>
<p>这里getRegistry返回的是实例化<code>XmlBeanDefinitionReader</code>时传入的beanFactory，所以回到DefaultListableBeanFactory#registerBeanDefinition。</p>
<p>关于设置<code>GenericBeanDefinition</code>实例的属性，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.beanClass = beanClassName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBeanClassName</span><span class="params">()</span> </span>&#123;</div><div class="line">	Object beanClassObject = <span class="keyword">this</span>.beanClass;</div><div class="line">	<span class="keyword">if</span> (beanClassObject <span class="keyword">instanceof</span> Class) &#123;</div><div class="line">		<span class="keyword">return</span> ((Class&lt;?&gt;) beanClassObject).getName();</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">return</span> (String) beanClassObject;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####3</p>
<p>接着跟踪源码来到AbstractApplicationContext#prepareBeanFactory中的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Configure the bean factory with context callbacks.</span></div><div class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</div></pre></td></tr></table></figure>
<p>看一下<code>ApplicationContextAwareProcessor</code>重写的postProcessBeforeInitialization方法，该方法会调用ApplicationContextAwareProcessor#invokeAwareInterfaces</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</div><div class="line">			((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</div><div class="line">			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(</div><div class="line">					<span class="keyword">new</span> EmbeddedValueResolver(<span class="keyword">this</span>.applicationContext.getBeanFactory()));</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</div><div class="line">			((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</div><div class="line">			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</div><div class="line">			((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</div><div class="line">			((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果bean实现了以下接口，包括<code>EnvironmentAware</code>、<code>EmbeddedValueResolverAware</code>、<code>ResourceLoaderAware</code>、<code>ApplicationEventPublisherAware</code>、<code>MessageSourceAware</code>、<code>ApplicationContextAware</code>，则bean在初始化之前，相应的实现方法将被调用。</p>
<p>#####4</p>
<p>跟踪源码来到AbstractApplicationContext#invokeBeanFactoryPostProcessors，获取beanFactory中已经注册的<code>BeanFactoryPostProcessor</code>，调用其中的postProcessBeanFactory方法。调用之前会判断处理器是否实现了<code>BeanDefinitionRegistryPostProcessor</code>接口，如果实现了，则先调用其中的postProcessBeanDefinitionRegistry方法，不再调用postProcessBeanFactory方法。</p>
<p><img src="https://moetu.fastmirror.org/images/2017/09/20/beanfactorypostprocessor_umle966b2defa9d4585.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String[] postProcessorNames =</div><div class="line">	beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p>再使用DefaultListableBeanFactory#getBeanNamesForType获取未注册的<code>BeanFactoryPostProcessor</code>，重复上述过程。</p>
<p>#####<a href="#registerBeanPostProcessors">5</a></p>
<p>接着跟踪源码来到AbstractApplicationContext#registerBeanPostProcessors，注册尚未注册的<code>BeanPostProcessor</code>，最后会重新注册实现了<code>MergedBeanDefinitionPostProcessor</code>接口的处理器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></div><div class="line">sortPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line">registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</div><div class="line"></div><div class="line"><span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></div><div class="line">...</div><div class="line">sortPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line">registerBeanPostProcessors(beanFactory, orderedPostProcessors);</div><div class="line"></div><div class="line"><span class="comment">// Now, register all regular BeanPostProcessors.</span></div><div class="line">...</div><div class="line">registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</div><div class="line"></div><div class="line"><span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></div><div class="line">sortPostProcessors(beanFactory, internalPostProcessors);</div><div class="line">registerBeanPostProcessors(beanFactory, internalPostProcessors);</div></pre></td></tr></table></figure>
<p><img src="https://moetu.fastmirror.org/images/2017/09/20/beanpostprocessor_uml046fb3f461390697.jpg" alt=""></p>
<p>#####6</p>
<p>接着初始化<code>MessageSource</code>、<code>ApplicationEventMulticaster</code>，注册监听者并广播早期的<code>ApplicationEvents</code>。</p>
<p><a href="#todo"><em>TODO</em></a></p>
<ul>
<li>DefaultListableBeanFactory#preInstantiateSingletons</li>
<li>AbstractBeanFactory#doGetBean</li>
</ul>
<p>最后初始化<code>LifecycleProcessor</code>。</p>
<p>#####7</p>
<p><a href="http://blog.163.com/axuandebin@126/blog/static/118777042009410248557/" target="_blank" rel="external">Spring容器-ApplicationContext的启动过程</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/preinstantiatesingletons/" class="prev">上一篇</a><a href="/class-defined-readresolve/" class="next">下一篇</a></div><div class="copyright"><p>© 2014 - 2017 <a href="https://g.hijkl.mn">Jemoii</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>